日期:2009-12-19
 15:30:56
文件 “QTRunner_VBS.rar”(43KB)已成功上传至服务器，我们将为您的好友保存 7 天。  
    

陈能技 15:33:04
写了个执行测试的框架，用VBS写的，试了一下，好像C#通过QTP的AOM调用会有问题，没有VBS和VB那么顺利日期:2009-12-20
一缕温暖 10:47:45
你用C#不能调用AOM？
陈能技 10:49:10
有，不过有时会失败
一缕温暖 10:49:37
是不是说什么远程调用失败？
陈能技 10:50:37
实例化Application时就出错
一缕温暖 10:51:16
那很可能你上次运行的实例没有在内存关闭
一缕温暖 10:51:32
QTP这个混蛋只允许一个实例在运行
陈能技 10:51:39
关了
一缕温暖 10:52:43
 
一缕温暖 10:53:06
这个关闭了？
陈能技 10:53:36
关了
陈能技 10:53:41
System.Runtime.InteropServices.COMException (0x80010105): 服务器出现意外情况。 (异常来自 HRESULT:0x80010105 (RPC_E_SERVERFAULT))
陈能技 10:55:33
用VB和VBS调用就不会
陈能技 10:56:07
QTP10+VS.NET2005
 10:56:12
成功发送文件“QTRunner_C#.rar”(73.00KB)。 
    

一缕温暖 10:58:29
你等等，我找找我的控制AOM的代码
一缕温暖 11:04:44
            // 创建QTP应用程序实例

            QuickTest.Application app = new QuickTest.Application();
            
            // 启动QTP
            app.Launch();
            // 让QTP可见
            app.Visible = true;

陈能技 11:05:17
嗯，我的是这样做的
一缕温暖 11:06:40
你是运行哪个文件？
陈能技 11:07:32
运行哪个文件？QTP的文件？
一缕温暖 11:07:59
我试试你的程序
 11:08:34
成功发送文件“Tests.rar”(24.00KB)。 
    

陈能技 11:08:50
这个应该和QTP文件没关系，它是在   QuickTest.Application app = new QuickTest.Application();这句就出错了
一缕温暖 11:09:22
是有时候失败？
陈能技 11:10:01
对
一缕温暖 11:55:05
好像在一个进程中只能起一次QucikAppliction
一缕温暖 11:55:42
只用Quick是无法完全释放COM对象
一缕温暖 11:55:59
不知是.net的转换没做好还是什么
陈能技 11:56:38
是啊，我在VB调用都很正常
一缕温暖 11:57:33
要搞这个问题要好好研究C#调用COM的机制才行
一缕温暖 11:58:12
折中的方法就是，在程序内只起一个QuickApplication的对象
一缕温暖 11:58:22
这样就可以解决问题
一缕温暖 11:59:07
QuickTest.Application QTPApplication = new QuickTest.ApplicationClass();
这个动作在整个程序启动的时候初始化，程序关闭的时候再Quick
一缕温暖 11:59:11
应该就没有问题了
陈能技 11:59:52
即是放到InitializeComponent中
日期:2009-12-20 
一缕温暖 12:00:12
嗯，在程序内都作为全局变量 
一缕温暖 12:00:35
因为。net有程序域的概念，以前的编程都没有 
一缕温暖 12:00:51
我估计是跟内存回收机制有关 
陈能技 12:01:12
没深入研究这方面的 
一缕温暖 12:01:38
我觉得上面哪个方法可以暂时解决这个问题 
一缕温暖 12:02:07
反正我们不是要研究QTP的AOM，只是用它而已 
陈能技 12:02:58
Quite放在Dispose里面还是哪里？ 
一缕温暖 12:58:43
窗体的话放在Close，或者这个都行啊 
一缕温暖 13:00:03
如果用类进行了封装就实现一个IDisposable接口 
一缕温暖 13:06:58
我试过了，换成这种模式，就不会出现错误了 
陈能技 13:16:27
这种方法应该没问题，但是如果想在测试过程中重新启动QTP则会有问题 
一缕温暖 13:16:59
问题是QTP本来就只能运行一个实例 
陈能技 13:17:07
在运行大量测试时QTP会有内存泄漏，可能需要定时重启 
一缕温暖 13:18:07
我试过了对QTP对象进行显式的内存回收都不行 
陈能技 13:19:13
在代码中单独启动一个进程来做应该可以，在这个单独的进程中实例化和退出，再用一个主进程控制这个进程 
一缕温暖 13:20:07
你这样的话只能做一个调度代理 
一缕温暖 13:20:16
那就是QTP的做法 
陈能技 13:21:26
就是为了调度，防止QTP内存泄漏，运行越来越慢 
陈能技 13:23:00
也就是说我现在写的这个小程序相当于Agent，再写个Controller来实现监控和调度 
陈能技 13:24:35
如果考虑分布式执行的话，也有必要有个Controller 
一缕温暖 13:27:59
我觉得QTP在启动的时候肯定是在注册表的地方写了信息 
一缕温暖 13:29:02
现在的情况就是，new那个Application的 “成功-》失败-》成功-》失败” 
陈能技 13:30:50
我现在在看那个ReporterManager，我觉得可以把这个报告框架整合进来，尤其是它支持把测试报告写到数据库中 
一缕温暖 13:32:05
我再看看AOM要怎么释放 
陈能技 13:32:24
好 
一缕温暖 14:00:09
现在可以了 
一缕温暖 14:00:19
不过AOM释放需要一点点时间 
一缕温暖 14:01:02
我通过手工显式释放，不能释放完马上再次运行，稍微等几秒钟了 
陈能技 14:01:49
在程序中设置延时就可以了 
一缕温暖 14:02:29
            try
            {
                QuickTest.Application QTPApplication = new QuickTest.ApplicationClass();           
                QTPApplication.Launch();
                QTPApplication.AutomationSilent = true;
                QTPApplication.Visible = false;
                string ResultPath = this.textBox2.Text;
                QTPApplication.Options.Run.RunMode = "Fast";
                QTPApplication.Options.Run.ViewResults = false;
                for (int i = 0; i < listBox1.Items.Count; i++)
                {
                    QTPApplication.Open(listBox1.Items[i].ToString(), true, false);
                    QuickTest.Test qtTest = QTPApplication.Test;
                    QuickTest.RunResultsOptions qtResult = new QuickTest.RunResultsOptions();
                    qtResult.ResultsLocation = ResultPath + "\\" + qtTest.Name.ToString();

                    
                    qtTest.Run(qtResult, true, null);
                    qtTest.Close();
                    
                    System.Runtime.InteropServices.Marshal.ReleaseComObject(qtResult);qtResult = null;
                    System.Runtime.InteropServices.Marshal.ReleaseComObject(qtTest); qtTest = null;
                }

                //QTPApplication.Quit();

                bool k=QTPApplication.Launched;
                QTPApplication.Quit();
                k = QTPApplication.Launched;
                System.Runtime.InteropServices.Marshal.ReleaseComObject(QTPApplication);
                QTPApplication = null;
                
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
            }
  
一缕温暖 14:03:42
手工释放由COM内部新建的对象 
一缕温暖 14:03:57
释放COM对象本身 
一缕温暖 14:04:35
引入失败尝试+延时的模式就可以解决这个问题了 
陈能技 14:05:40
如果要完全避免内存泄漏，需要注意每次用完COM内部对象就要及时用你这种方式释放内存，就像在VBS中的=Nothing一样 
一缕温暖 14:06:39
嗯，由于COM对象属于非托管对象。。net的本身垃圾回收机制是不能回收内存 
陈能技 14:10:21
QTPApplication.AutomationSilent = true;是不是运行速度会快点？
 
一缕温暖 14:10:49
这些你可以不做，顶多就是引起内存泄露。延时一定要做，不然AOM本身有回收时间 
一缕温暖 14:11:31
，是啊，这个是不启用UI模式运行QTP，就是纯调用QTP的API运行脚本 
陈能技 14:12:08
这样的话需不需要安装QTP？ 
一缕温暖 14:12:20
我觉得要 
一缕温暖 14:12:45
QTP的DLL很多要写入注册表 
陈能技 14:12:48
我也觉得是 
一缕温暖 14:13:29
不过如果我们可以找到要那些DLL和注册表信息的话，我觉得有可能不需要安装。 
陈能技 14:14:11
这样做没有太多的必要吧 
一缕温暖 14:14:34
呵呵，其实就像那些绿色版软件一样 
一缕温暖 14:15:03
不过QTP大量使用了COM+技术，所以弄起来特别麻烦 
一缕温暖 14:16:01
SilkTest，RFT这些基于新一代编程技术的就比qtp优势明显了 
一缕温暖 14:17:32
用Silent模式就已经比用UI模式快很多了 
陈能技 14:17:42
RFT可以不安装，通过访问API运行测试吗？ 
一缕温暖 14:18:33
silktest支持分布式测试 
一缕温暖 14:18:43
可以在目标机装agent就行了 
陈能技 14:18:57
TestComplete也是这种模式的 
一缕温暖 14:19:02
不过agent都是要收费的 
一缕温暖 14:19:10
RFT我没研究过 
一缕温暖 14:19:47
但是RFT是基于java的，估计移值应该很容易的 
一缕温暖 14:19:55
就是一大堆包 
陈能技 14:20:13
呵呵，是啊 
一缕温暖 14:20:34
所以说QTP会落后的，安装目前的发展下去 
一缕温暖 14:21:08
如果HP不用新的架构重新设计qtp 
